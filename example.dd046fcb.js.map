{"version":3,"sources":["../../node_modules/@fluent/langneg/esm/subtags.js","../../node_modules/@fluent/langneg/esm/locale.js","../../node_modules/@fluent/langneg/esm/matches.js","../../node_modules/@fluent/langneg/esm/negotiate_languages.js","../../node_modules/@fluent/langneg/esm/accepted_languages.js","../../node_modules/@fluent/langneg/esm/index.js","../../node_modules/@fluent/bundle/esm/types.js","../../node_modules/@fluent/bundle/esm/resolver.js","../../node_modules/@fluent/bundle/esm/scope.js","../../node_modules/@fluent/bundle/esm/builtins.js","../../node_modules/@fluent/bundle/esm/bundle.js","../../node_modules/@fluent/bundle/esm/resource.js","../../node_modules/@fluent/bundle/esm/index.js","../common/resources.js","example.js"],"names":["likelySubtagsMin","regionMatchingLangs","getLikelySubtagsMin","loc","hasOwnProperty","Locale","locale","language","includes","region","toUpperCase","languageCodeRe","scriptCodeRe","regionCodeRe","variantCodeRe","localeRe","RegExp","constructor","result","exec","replace","isWellFormed","script","variant","toLowerCase","slice","isEqual","other","matches","thisRange","otherRange","undefined","toString","filter","part","join","clearVariants","clearRegion","addLikelySubtags","newLocale","filterMatches","requestedLocales","availableLocales","strategy","supportedLocales","Set","availableLocalesMap","Map","set","outer","reqLocStr","reqLocStrLC","requestedLocale","key","keys","add","delete","Array","from","availableLocale","entries","negotiateLanguages","defaultLocale","Object","map","String","Error","length","push","acceptedLanguages","str","TypeError","tokens","split","t","trim","FluentType","value","valueOf","FluentNone","scope","FluentNumber","opts","nf","memoizeIntlObject","Intl","NumberFormat","format","err","reportError","FluentDateTime","dtf","DateTimeFormat","Date","toISOString","MAX_PLACEABLES","FSI","PDI","match","selector","PluralRules","select","getDefault","variants","star","resolvePattern","RangeError","getArguments","args","positional","named","create","arg","type","name","resolveExpression","expr","minimumFractionDigits","precision","resolveVariableReference","resolveMessageReference","resolveTermReference","resolveFunctionReference","resolveSelectExpression","params","prototype","call","ReferenceError","getTime","attr","message","bundle","_messages","get","attribute","attributes","id","term","_terms","resolved","func","_functions","sel","resolveComplexPattern","ptn","dirty","has","useIsolating","_useIsolating","elem","placeables","_transform","Scope","errors","WeakSet","error","ctor","cache","_intls","JSON","stringify","locales","values","allowed","unwrapped","opt","NUMBER_ALLOWED","NUMBER","DATETIME_ALLOWED","DATETIME","FluentBundle","functions","transform","v","WeakMap","isArray","hasMessage","getMessage","addResource","res","allowOverrides","i","body","entry","startsWith","formatPattern","pattern","RE_MESSAGE_START","RE_ATTRIBUTE_START","RE_VARIANT_START","RE_NUMBER_LITERAL","RE_IDENTIFIER","RE_REFERENCE","RE_FUNCTION_NAME","RE_TEXT_RUN","RE_STRING_RUN","RE_STRING_ESCAPE","RE_UNICODE_ESCAPE","RE_LEADING_NEWLINES","RE_TRAILING_SPACES","RE_BLANK_LINES","RE_INDENT","TOKEN_BRACE_OPEN","TOKEN_BRACE_CLOSE","TOKEN_BRACKET_OPEN","TOKEN_BRACKET_CLOSE","TOKEN_PAREN_OPEN","TOKEN_ARROW","TOKEN_COLON","TOKEN_COMMA","TOKEN_BLANK","FluentResource","source","lastIndex","cursor","next","parseMessage","SyntaxError","test","re","consumeChar","char","errorClass","consumeToken","match1","parsePattern","parseAttributes","attrs","first","parsePatternElements","Infinity","indent","parseIndent","elements","commonIndent","parsePlaceable","Math","min","lastElement","baked","element","Indent","parseInlineExpression","parseVariants","count","parseVariantKey","sigil","parseArguments","parseArgument","parseLiteral","parseNumberLiteral","parseStringLiteral","parseEscapeSequence","fraction","parseFloat","codepoint4","codepoint6","codepoint","parseInt","fromCodePoint","start","makeIndent","text","blank","enUS","pl","cs","thTH","eo","resources","getCurrentLocales","desiredLocales","getBundles","currentLocales","bundles","window","addEventListener","event","console","app","Elm","Example","init","node","document","getElementById","flags","navigator","languages","initialLocale","ports","changeDesirecLocale","subscribe","gotBundles","send"],"mappings":"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","file":"example.dd046fcb.js","sourceRoot":"example/elm","sourcesContent":["import { Locale } from \"./locale\";\n/**\n * Below is a manually a list of likely subtags corresponding to Unicode\n * CLDR likelySubtags list.\n * This list is curated by the maintainers of Project Fluent and is\n * intended to be used in place of the full likelySubtags list in use cases\n * where full list cannot be (for example, due to the size).\n *\n * This version of the list is based on CLDR 30.0.3.\n */\nconst likelySubtagsMin = {\n    \"ar\": \"ar-arab-eg\",\n    \"az-arab\": \"az-arab-ir\",\n    \"az-ir\": \"az-arab-ir\",\n    \"be\": \"be-cyrl-by\",\n    \"da\": \"da-latn-dk\",\n    \"el\": \"el-grek-gr\",\n    \"en\": \"en-latn-us\",\n    \"fa\": \"fa-arab-ir\",\n    \"ja\": \"ja-jpan-jp\",\n    \"ko\": \"ko-kore-kr\",\n    \"pt\": \"pt-latn-br\",\n    \"sr\": \"sr-cyrl-rs\",\n    \"sr-ru\": \"sr-latn-ru\",\n    \"sv\": \"sv-latn-se\",\n    \"ta\": \"ta-taml-in\",\n    \"uk\": \"uk-cyrl-ua\",\n    \"zh\": \"zh-hans-cn\",\n    \"zh-hant\": \"zh-hant-tw\",\n    \"zh-hk\": \"zh-hant-hk\",\n    \"zh-gb\": \"zh-hant-gb\",\n    \"zh-us\": \"zh-hant-us\",\n};\nconst regionMatchingLangs = [\n    \"az\",\n    \"bg\",\n    \"cs\",\n    \"de\",\n    \"es\",\n    \"fi\",\n    \"fr\",\n    \"hu\",\n    \"it\",\n    \"lt\",\n    \"lv\",\n    \"nl\",\n    \"pl\",\n    \"ro\",\n    \"ru\",\n];\nexport function getLikelySubtagsMin(loc) {\n    if (likelySubtagsMin.hasOwnProperty(loc)) {\n        return new Locale(likelySubtagsMin[loc]);\n    }\n    const locale = new Locale(loc);\n    if (locale.language && regionMatchingLangs.includes(locale.language)) {\n        locale.region = locale.language.toUpperCase();\n        return locale;\n    }\n    return null;\n}\n","/* eslint no-magic-numbers: 0 */\nimport { getLikelySubtagsMin } from \"./subtags\";\nconst languageCodeRe = \"([a-z]{2,3}|\\\\*)\";\nconst scriptCodeRe = \"(?:-([a-z]{4}|\\\\*))\";\nconst regionCodeRe = \"(?:-([a-z]{2}|\\\\*))\";\nconst variantCodeRe = \"(?:-(([0-9][a-z0-9]{3}|[a-z0-9]{5,8})|\\\\*))\";\n/**\n * Regular expression splitting locale id into four pieces:\n *\n * Example: `en-Latn-US-macos`\n *\n * language: en\n * script:   Latn\n * region:   US\n * variant:  macos\n *\n * It can also accept a range `*` character on any position.\n */\nconst localeRe = new RegExp(`^${languageCodeRe}${scriptCodeRe}?${regionCodeRe}?${variantCodeRe}?$`, \"i\");\nexport class Locale {\n    /**\n     * Parses a locale id using the localeRe into an array with four elements.\n     *\n     * If the second argument `range` is set to true, it places range `*` char\n     * in place of any missing piece.\n     *\n     * It also allows skipping the script section of the id, so `en-US` is\n     * properly parsed as `en-*-US-*`.\n     */\n    constructor(locale) {\n        const result = localeRe.exec(locale.replace(/_/g, \"-\"));\n        if (!result) {\n            this.isWellFormed = false;\n            return;\n        }\n        let [, language, script, region, variant] = result;\n        if (language) {\n            this.language = language.toLowerCase();\n        }\n        if (script) {\n            this.script = script[0].toUpperCase() + script.slice(1);\n        }\n        if (region) {\n            this.region = region.toUpperCase();\n        }\n        this.variant = variant;\n        this.isWellFormed = true;\n    }\n    isEqual(other) {\n        return this.language === other.language\n            && this.script === other.script\n            && this.region === other.region\n            && this.variant === other.variant;\n    }\n    matches(other, thisRange = false, otherRange = false) {\n        return (this.language === other.language\n            || thisRange && this.language === undefined\n            || otherRange && other.language === undefined)\n            && (this.script === other.script\n                || thisRange && this.script === undefined\n                || otherRange && other.script === undefined)\n            && (this.region === other.region\n                || thisRange && this.region === undefined\n                || otherRange && other.region === undefined)\n            && (this.variant === other.variant\n                || thisRange && this.variant === undefined\n                || otherRange && other.variant === undefined);\n    }\n    toString() {\n        return [this.language, this.script, this.region, this.variant]\n            .filter(part => part !== undefined)\n            .join(\"-\");\n    }\n    clearVariants() {\n        this.variant = undefined;\n    }\n    clearRegion() {\n        this.region = undefined;\n    }\n    addLikelySubtags() {\n        const newLocale = getLikelySubtagsMin(this.toString().toLowerCase());\n        if (newLocale) {\n            this.language = newLocale.language;\n            this.script = newLocale.script;\n            this.region = newLocale.region;\n            this.variant = newLocale.variant;\n            return true;\n        }\n        return false;\n    }\n}\n","/* eslint no-magic-numbers: 0 */\nimport { Locale } from \"./locale\";\n/**\n * Negotiates the languages between the list of requested locales against\n * a list of available locales.\n *\n * The algorithm is based on the BCP4647 3.3.2 Extended Filtering algorithm,\n * with several modifications:\n *\n *  1) available locales are treated as ranges\n *\n *    This change allows us to match a more specific request against\n *    more generic available locale.\n *\n *    For example, if the available locale list provides locale `en`,\n *    and the requested locale is `en-US`, we treat the available locale as\n *    a locale that matches all possible english requests.\n *\n *    This means that we expect available locale ID to be as precize as\n *    the matches they want to cover.\n *\n *    For example, if there is only `sr` available, it's ok to list\n *    it in available locales. But once the available locales has both,\n *    Cyrl and Latn variants, the locale IDs should be `sr-Cyrl` and `sr-Latn`\n *    to avoid any `sr-*` request to match against whole `sr` range.\n *\n *    What it does ([requested] * [available] = [supported]):\n *\n *    ['en-US'] * ['en'] = ['en']\n *\n *  2) likely subtags from LDML 4.3 Likely Subtags has been added\n *\n *    The most obvious likely subtag that can be computed is a duplication\n *    of the language field onto region field (`fr` => `fr-FR`).\n *\n *    On top of that, likely subtags may use a list of mappings, that\n *    allow the algorithm to handle non-obvious matches.\n *    For example, making sure that we match `en` to `en-US` or `sr` to\n *    `sr-Cyrl`, while `sr-RU` to `sr-Latn-RU`.\n *\n *    This list can be taken directly from CLDR Supplemental Data.\n *\n *    What it does ([requested] * [available] = [supported]):\n *\n *    ['fr'] * ['fr-FR'] = ['fr-FR']\n *    ['en'] * ['en-US'] = ['en-US']\n *    ['sr'] * ['sr-Latn', 'sr-Cyrl'] = ['sr-Cyrl']\n *\n *  3) variant/region range check has been added\n *\n *    Lastly, the last form of check is against the requested locale ID\n *    but with the variant/region field replaced with a `*` range.\n *\n *    The rationale here laid out in LDML 4.4 Language Matching:\n *      \"(...) normally the fall-off between the user's languages is\n *      substantially greated than regional variants.\"\n *\n *    In other words, if we can't match for the given region, maybe\n *    we can match for the same language/script but other region, and\n *    it will in most cases be preferred over falling back on the next\n *    language.\n *\n *    What it does ([requested] * [available] = [supported]):\n *\n *    ['en-AU'] * ['en-US'] = ['en-US']\n *    ['sr-RU'] * ['sr-Latn-RO'] = ['sr-Latn-RO'] // sr-RU -> sr-Latn-RU\n *\n *    It works similarly to getParentLocales algo, except that we stop\n *    after matching against variant/region ranges and don't try to match\n *    ignoring script ranges. That means that `sr-Cyrl` will never match\n *    against `sr-Latn`.\n */\nexport function filterMatches(requestedLocales, availableLocales, strategy) {\n    const supportedLocales = new Set();\n    const availableLocalesMap = new Map();\n    for (let locale of availableLocales) {\n        let newLocale = new Locale(locale);\n        if (newLocale.isWellFormed) {\n            availableLocalesMap.set(locale, new Locale(locale));\n        }\n    }\n    outer: for (const reqLocStr of requestedLocales) {\n        const reqLocStrLC = reqLocStr.toLowerCase();\n        const requestedLocale = new Locale(reqLocStrLC);\n        if (requestedLocale.language === undefined) {\n            continue;\n        }\n        // 1) Attempt to make an exact match\n        // Example: `en-US` === `en-US`\n        for (const key of availableLocalesMap.keys()) {\n            if (reqLocStrLC === key.toLowerCase()) {\n                supportedLocales.add(key);\n                availableLocalesMap.delete(key);\n                if (strategy === \"lookup\") {\n                    return Array.from(supportedLocales);\n                }\n                else if (strategy === \"filtering\") {\n                    continue;\n                }\n                else {\n                    continue outer;\n                }\n            }\n        }\n        // 2) Attempt to match against the available range\n        // This turns `en` into `en-*-*-*` and `en-US` into `en-*-US-*`\n        // Example: ['en-US'] * ['en'] = ['en']\n        for (const [key, availableLocale] of availableLocalesMap.entries()) {\n            if (availableLocale.matches(requestedLocale, true, false)) {\n                supportedLocales.add(key);\n                availableLocalesMap.delete(key);\n                if (strategy === \"lookup\") {\n                    return Array.from(supportedLocales);\n                }\n                else if (strategy === \"filtering\") {\n                    continue;\n                }\n                else {\n                    continue outer;\n                }\n            }\n        }\n        // 3) Attempt to retrieve a maximal version of the requested locale ID\n        // If data is available, it'll expand `en` into `en-Latn-US` and\n        // `zh` into `zh-Hans-CN`.\n        // Example: ['en'] * ['en-GB', 'en-US'] = ['en-US']\n        if (requestedLocale.addLikelySubtags()) {\n            for (const [key, availableLocale] of availableLocalesMap.entries()) {\n                if (availableLocale.matches(requestedLocale, true, false)) {\n                    supportedLocales.add(key);\n                    availableLocalesMap.delete(key);\n                    if (strategy === \"lookup\") {\n                        return Array.from(supportedLocales);\n                    }\n                    else if (strategy === \"filtering\") {\n                        continue;\n                    }\n                    else {\n                        continue outer;\n                    }\n                }\n            }\n        }\n        // 4) Attempt to look up for a different variant for the same locale ID\n        // Example: ['en-US-mac'] * ['en-US-win'] = ['en-US-win']\n        requestedLocale.clearVariants();\n        for (const [key, availableLocale] of availableLocalesMap.entries()) {\n            if (availableLocale.matches(requestedLocale, true, true)) {\n                supportedLocales.add(key);\n                availableLocalesMap.delete(key);\n                if (strategy === \"lookup\") {\n                    return Array.from(supportedLocales);\n                }\n                else if (strategy === \"filtering\") {\n                    continue;\n                }\n                else {\n                    continue outer;\n                }\n            }\n        }\n        // 5) Attempt to match against the likely subtag without region\n        // In the example below, addLikelySubtags will turn\n        // `zh-Hant` into `zh-Hant-TW` giving `zh-TW` priority match\n        // over `zh-CN`.\n        //\n        // Example: ['zh-Hant-HK'] * ['zh-TW', 'zh-CN'] = ['zh-TW']\n        requestedLocale.clearRegion();\n        if (requestedLocale.addLikelySubtags()) {\n            for (const [key, availableLocale] of availableLocalesMap.entries()) {\n                if (availableLocale.matches(requestedLocale, true, false)) {\n                    supportedLocales.add(key);\n                    availableLocalesMap.delete(key);\n                    if (strategy === \"lookup\") {\n                        return Array.from(supportedLocales);\n                    }\n                    else if (strategy === \"filtering\") {\n                        continue;\n                    }\n                    else {\n                        continue outer;\n                    }\n                }\n            }\n        }\n        // 6) Attempt to look up for a different region for the same locale ID\n        // Example: ['en-US'] * ['en-AU'] = ['en-AU']\n        requestedLocale.clearRegion();\n        for (const [key, availableLocale] of availableLocalesMap.entries()) {\n            if (availableLocale.matches(requestedLocale, true, true)) {\n                supportedLocales.add(key);\n                availableLocalesMap.delete(key);\n                if (strategy === \"lookup\") {\n                    return Array.from(supportedLocales);\n                }\n                else if (strategy === \"filtering\") {\n                    continue;\n                }\n                else {\n                    continue outer;\n                }\n            }\n        }\n    }\n    return Array.from(supportedLocales);\n}\n","import { filterMatches } from \"./matches\";\n/**\n * Negotiates the languages between the list of requested locales against\n * a list of available locales.\n *\n * It accepts three arguments:\n *\n *   requestedLocales:\n *     an Array of strings with BCP47 locale IDs sorted\n *     according to user preferences.\n *\n *   availableLocales:\n *     an Array of strings with BCP47 locale IDs of locale for which\n *     resources are available. Unsorted.\n *\n *   options:\n *     An object with the following, optional keys:\n *\n *       strategy: 'filtering' (default) | 'matching' | 'lookup'\n *\n *       defaultLocale:\n *         a string with BCP47 locale ID to be used\n *         as a last resort locale.\n *\n *\n * It returns an Array of strings with BCP47 locale IDs sorted according to the\n * user preferences.\n *\n * The exact list will be selected differently depending on the strategy:\n *\n *   'filtering': (default)\n *     In the filtering strategy, the algorithm will attempt to match\n *     as many keys in the available locales in order of the requested locales.\n *\n *   'matching':\n *     In the matching strategy, the algorithm will attempt to find the\n *     best possible match for each element of the requestedLocales list.\n *\n *   'lookup':\n *     In the lookup strategy, the algorithm will attempt to find a single\n *     best available locale based on the requested locales list.\n *\n *     This strategy requires defaultLocale option to be set.\n */\nexport function negotiateLanguages(requestedLocales, availableLocales, { strategy = \"filtering\", defaultLocale, } = {}) {\n    const supportedLocales = filterMatches(Array.from(Object(requestedLocales)).map(String), Array.from(Object(availableLocales)).map(String), strategy);\n    if (strategy === \"lookup\") {\n        if (defaultLocale === undefined) {\n            throw new Error(\"defaultLocale cannot be undefined for strategy `lookup`\");\n        }\n        if (supportedLocales.length === 0) {\n            supportedLocales.push(defaultLocale);\n        }\n    }\n    else if (defaultLocale && !supportedLocales.includes(defaultLocale)) {\n        supportedLocales.push(defaultLocale);\n    }\n    return supportedLocales;\n}\n","export function acceptedLanguages(str = \"\") {\n    if (typeof str !== \"string\") {\n        throw new TypeError(\"Argument must be a string\");\n    }\n    const tokens = str.split(\",\").map(t => t.trim());\n    return tokens.filter(t => t !== \"\").map(t => t.split(\";\")[0]);\n}\n","/*\n * @module fluent-langneg\n * @overview\n *\n * `fluent-langneg` provides language negotiation API that fits into\n * Project Fluent localization composition and fallbacking strategy.\n *\n */\nexport { negotiateLanguages } from \"./negotiate_languages\";\nexport { acceptedLanguages } from \"./accepted_languages\";\n","/**\n * The `FluentType` class is the base of Fluent's type system.\n *\n * Fluent types wrap JavaScript values and store additional configuration for\n * them, which can then be used in the `toString` method together with a proper\n * `Intl` formatter.\n */\nexport class FluentType {\n    /**\n     * Create a `FluentType` instance.\n     *\n     * @param value The JavaScript value to wrap.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Unwrap the raw value stored by this `FluentType`.\n     */\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * A `FluentType` representing no correct value.\n */\nexport class FluentNone extends FluentType {\n    /**\n     * Create an instance of `FluentNone` with an optional fallback value.\n     * @param value The fallback value of this `FluentNone`.\n     */\n    constructor(value = \"???\") {\n        super(value);\n    }\n    /**\n     * Format this `FluentNone` to the fallback string.\n     */\n    toString(scope) {\n        return `{${this.value}}`;\n    }\n}\n/**\n * A `FluentType` representing a number.\n *\n * A `FluentNumber` instance stores the number value of the number it\n * represents. It may also store an option bag of options which will be passed\n * to `Intl.NumerFormat` when the `FluentNumber` is formatted to a string.\n */\nexport class FluentNumber extends FluentType {\n    /**\n     * Create an instance of `FluentNumber` with options to the\n     * `Intl.NumberFormat` constructor.\n     *\n     * @param value The number value of this `FluentNumber`.\n     * @param opts Options which will be passed to `Intl.NumberFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentNumber` to a string.\n     */\n    toString(scope) {\n        try {\n            const nf = scope.memoizeIntlObject(Intl.NumberFormat, this.opts);\n            return nf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return this.value.toString(10);\n        }\n    }\n}\n/**\n * A `FluentType` representing a date and time.\n *\n * A `FluentDateTime` instance stores the number value of the date it\n * represents, as a numerical timestamp in milliseconds. It may also store an\n * option bag of options which will be passed to `Intl.DateTimeFormat` when the\n * `FluentDateTime` is formatted to a string.\n */\nexport class FluentDateTime extends FluentType {\n    /**\n     * Create an instance of `FluentDateTime` with options to the\n     * `Intl.DateTimeFormat` constructor.\n     *\n     * @param value The number value of this `FluentDateTime`, in milliseconds.\n     * @param opts Options which will be passed to `Intl.DateTimeFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentDateTime` to a string.\n     */\n    toString(scope) {\n        try {\n            const dtf = scope.memoizeIntlObject(Intl.DateTimeFormat, this.opts);\n            return dtf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return new Date(this.value).toISOString();\n        }\n    }\n}\n","/* global Intl */\n/**\n * @overview\n *\n * The role of the Fluent resolver is to format a `Pattern` to an instance of\n * `FluentValue`. For performance reasons, primitive strings are considered\n * such instances, too.\n *\n * Translations can contain references to other messages or variables,\n * conditional logic in form of select expressions, traits which describe their\n * grammatical features, and can use Fluent builtins which make use of the\n * `Intl` formatters to format numbers and dates into the bundle's languages.\n * See the documentation of the Fluent syntax for more information.\n *\n * In case of errors the resolver will try to salvage as much of the\n * translation as possible. In rare situations where the resolver didn't know\n * how to recover from an error it will return an instance of `FluentNone`.\n *\n * All expressions resolve to an instance of `FluentValue`. The caller should\n * use the `toString` method to convert the instance to a native value.\n *\n * Functions in this file pass around an instance of the `Scope` class, which\n * stores the data required for successful resolution and error recovery.\n */\nimport { FluentType, FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\n// The maximum number of placeables which can be expanded in a single call to\n// `formatPattern`. The limit protects against the Billion Laughs and Quadratic\n// Blowup attacks. See https://msdn.microsoft.com/en-us/magazine/ee335713.aspx.\nconst MAX_PLACEABLES = 100;\n// Unicode bidi isolation characters.\nconst FSI = \"\\u2068\";\nconst PDI = \"\\u2069\";\n// Helper: match a variant key to the given selector.\nfunction match(scope, selector, key) {\n    if (key === selector) {\n        // Both are strings.\n        return true;\n    }\n    // XXX Consider comparing options too, e.g. minimumFractionDigits.\n    if (key instanceof FluentNumber &&\n        selector instanceof FluentNumber &&\n        key.value === selector.value) {\n        return true;\n    }\n    if (selector instanceof FluentNumber && typeof key === \"string\") {\n        let category = scope\n            .memoizeIntlObject(Intl.PluralRules, selector.opts)\n            .select(selector.value);\n        if (key === category) {\n            return true;\n        }\n    }\n    return false;\n}\n// Helper: resolve the default variant from a list of variants.\nfunction getDefault(scope, variants, star) {\n    if (variants[star]) {\n        return resolvePattern(scope, variants[star].value);\n    }\n    scope.reportError(new RangeError(\"No default\"));\n    return new FluentNone();\n}\n// Helper: resolve arguments to a call expression.\nfunction getArguments(scope, args) {\n    const positional = [];\n    const named = Object.create(null);\n    for (const arg of args) {\n        if (arg.type === \"narg\") {\n            named[arg.name] = resolveExpression(scope, arg.value);\n        }\n        else {\n            positional.push(resolveExpression(scope, arg));\n        }\n    }\n    return { positional, named };\n}\n// Resolve an expression to a Fluent type.\nfunction resolveExpression(scope, expr) {\n    switch (expr.type) {\n        case \"str\":\n            return expr.value;\n        case \"num\":\n            return new FluentNumber(expr.value, {\n                minimumFractionDigits: expr.precision\n            });\n        case \"var\":\n            return resolveVariableReference(scope, expr);\n        case \"mesg\":\n            return resolveMessageReference(scope, expr);\n        case \"term\":\n            return resolveTermReference(scope, expr);\n        case \"func\":\n            return resolveFunctionReference(scope, expr);\n        case \"select\":\n            return resolveSelectExpression(scope, expr);\n        default:\n            return new FluentNone();\n    }\n}\n// Resolve a reference to a variable.\nfunction resolveVariableReference(scope, { name }) {\n    let arg;\n    if (scope.params) {\n        // We're inside a TermReference. It's OK to reference undefined parameters.\n        if (Object.prototype.hasOwnProperty.call(scope.params, name)) {\n            arg = scope.params[name];\n        }\n        else {\n            return new FluentNone(`$${name}`);\n        }\n    }\n    else if (scope.args\n        && Object.prototype.hasOwnProperty.call(scope.args, name)) {\n        // We're in the top-level Pattern or inside a MessageReference. Missing\n        // variables references produce ReferenceErrors.\n        arg = scope.args[name];\n    }\n    else {\n        scope.reportError(new ReferenceError(`Unknown variable: $${name}`));\n        return new FluentNone(`$${name}`);\n    }\n    // Return early if the argument already is an instance of FluentType.\n    if (arg instanceof FluentType) {\n        return arg;\n    }\n    // Convert the argument to a Fluent type.\n    switch (typeof arg) {\n        case \"string\":\n            return arg;\n        case \"number\":\n            return new FluentNumber(arg);\n        case \"object\":\n            if (arg instanceof Date) {\n                return new FluentDateTime(arg.getTime());\n            }\n        // eslint-disable-next-line no-fallthrough\n        default:\n            scope.reportError(new TypeError(`Variable type not supported: $${name}, ${typeof arg}`));\n            return new FluentNone(`$${name}`);\n    }\n}\n// Resolve a reference to another message.\nfunction resolveMessageReference(scope, { name, attr }) {\n    const message = scope.bundle._messages.get(name);\n    if (!message) {\n        scope.reportError(new ReferenceError(`Unknown message: ${name}`));\n        return new FluentNone(name);\n    }\n    if (attr) {\n        const attribute = message.attributes[attr];\n        if (attribute) {\n            return resolvePattern(scope, attribute);\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${name}.${attr}`);\n    }\n    if (message.value) {\n        return resolvePattern(scope, message.value);\n    }\n    scope.reportError(new ReferenceError(`No value: ${name}`));\n    return new FluentNone(name);\n}\n// Resolve a call to a Term with key-value arguments.\nfunction resolveTermReference(scope, { name, attr, args }) {\n    const id = `-${name}`;\n    const term = scope.bundle._terms.get(id);\n    if (!term) {\n        scope.reportError(new ReferenceError(`Unknown term: ${id}`));\n        return new FluentNone(id);\n    }\n    if (attr) {\n        const attribute = term.attributes[attr];\n        if (attribute) {\n            // Every TermReference has its own variables.\n            scope.params = getArguments(scope, args).named;\n            const resolved = resolvePattern(scope, attribute);\n            scope.params = null;\n            return resolved;\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${id}.${attr}`);\n    }\n    scope.params = getArguments(scope, args).named;\n    const resolved = resolvePattern(scope, term.value);\n    scope.params = null;\n    return resolved;\n}\n// Resolve a call to a Function with positional and key-value arguments.\nfunction resolveFunctionReference(scope, { name, args }) {\n    // Some functions are built-in. Others may be provided by the runtime via\n    // the `FluentBundle` constructor.\n    let func = scope.bundle._functions[name];\n    if (!func) {\n        scope.reportError(new ReferenceError(`Unknown function: ${name}()`));\n        return new FluentNone(`${name}()`);\n    }\n    if (typeof func !== \"function\") {\n        scope.reportError(new TypeError(`Function ${name}() is not callable`));\n        return new FluentNone(`${name}()`);\n    }\n    try {\n        let resolved = getArguments(scope, args);\n        return func(resolved.positional, resolved.named);\n    }\n    catch (err) {\n        scope.reportError(err);\n        return new FluentNone(`${name}()`);\n    }\n}\n// Resolve a select expression to the member object.\nfunction resolveSelectExpression(scope, { selector, variants, star }) {\n    let sel = resolveExpression(scope, selector);\n    if (sel instanceof FluentNone) {\n        return getDefault(scope, variants, star);\n    }\n    // Match the selector against keys of each variant, in order.\n    for (const variant of variants) {\n        const key = resolveExpression(scope, variant.key);\n        if (match(scope, sel, key)) {\n            return resolvePattern(scope, variant.value);\n        }\n    }\n    return getDefault(scope, variants, star);\n}\n// Resolve a pattern (a complex string with placeables).\nexport function resolveComplexPattern(scope, ptn) {\n    if (scope.dirty.has(ptn)) {\n        scope.reportError(new RangeError(\"Cyclic reference\"));\n        return new FluentNone();\n    }\n    // Tag the pattern as dirty for the purpose of the current resolution.\n    scope.dirty.add(ptn);\n    const result = [];\n    // Wrap interpolations with Directional Isolate Formatting characters\n    // only when the pattern has more than one element.\n    const useIsolating = scope.bundle._useIsolating && ptn.length > 1;\n    for (const elem of ptn) {\n        if (typeof elem === \"string\") {\n            result.push(scope.bundle._transform(elem));\n            continue;\n        }\n        scope.placeables++;\n        if (scope.placeables > MAX_PLACEABLES) {\n            scope.dirty.delete(ptn);\n            // This is a fatal error which causes the resolver to instantly bail out\n            // on this pattern. The length check protects against excessive memory\n            // usage, and throwing protects against eating up the CPU when long\n            // placeables are deeply nested.\n            throw new RangeError(`Too many placeables expanded: ${scope.placeables}, ` +\n                `max allowed is ${MAX_PLACEABLES}`);\n        }\n        if (useIsolating) {\n            result.push(FSI);\n        }\n        result.push(resolveExpression(scope, elem).toString(scope));\n        if (useIsolating) {\n            result.push(PDI);\n        }\n    }\n    scope.dirty.delete(ptn);\n    return result.join(\"\");\n}\n// Resolve a simple or a complex Pattern to a FluentString (which is really the\n// string primitive).\nfunction resolvePattern(scope, value) {\n    // Resolve a simple pattern.\n    if (typeof value === \"string\") {\n        return scope.bundle._transform(value);\n    }\n    return resolveComplexPattern(scope, value);\n}\n","export class Scope {\n    constructor(bundle, errors, args) {\n        /** The Set of patterns already encountered during this resolution.\n         * Used to detect and prevent cyclic resolutions. */\n        this.dirty = new WeakSet();\n        /** A dict of parameters passed to a TermReference. */\n        this.params = null;\n        /** The running count of placeables resolved so far. Used to detect the\n          * Billion Laughs and Quadratic Blowup attacks. */\n        this.placeables = 0;\n        this.bundle = bundle;\n        this.errors = errors;\n        this.args = args;\n    }\n    reportError(error) {\n        if (!this.errors) {\n            throw error;\n        }\n        this.errors.push(error);\n    }\n    memoizeIntlObject(ctor, opts) {\n        let cache = this.bundle._intls.get(ctor);\n        if (!cache) {\n            cache = {};\n            this.bundle._intls.set(ctor, cache);\n        }\n        let id = JSON.stringify(opts);\n        if (!cache[id]) {\n            cache[id] = new ctor(this.bundle.locales, opts);\n        }\n        return cache[id];\n    }\n}\n","/**\n * @overview\n *\n * The FTL resolver ships with a number of functions built-in.\n *\n * Each function take two arguments:\n *   - args - an array of positional args\n *   - opts - an object of key-value args\n *\n * Arguments to functions are guaranteed to already be instances of\n * `FluentValue`.  Functions must return `FluentValues` as well.\n */\nimport { FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\nfunction values(opts, allowed) {\n    const unwrapped = Object.create(null);\n    for (const [name, opt] of Object.entries(opts)) {\n        if (allowed.includes(name)) {\n            unwrapped[name] = opt.valueOf();\n        }\n    }\n    return unwrapped;\n}\nconst NUMBER_ALLOWED = [\n    \"unitDisplay\",\n    \"currencyDisplay\",\n    \"useGrouping\",\n    \"minimumIntegerDigits\",\n    \"minimumFractionDigits\",\n    \"maximumFractionDigits\",\n    \"minimumSignificantDigits\",\n    \"maximumSignificantDigits\",\n];\n/**\n * The implementation of the `NUMBER()` builtin available to translations.\n *\n * Translations may call the `NUMBER()` builtin in order to specify formatting\n * options of a number. For example:\n *\n *     pi = The value of  is {NUMBER($pi, maximumFractionDigits: 2)}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     unitDisplay\n *     currencyDisplay\n *     useGrouping\n *     minimumIntegerDigits\n *     minimumFractionDigits\n *     maximumFractionDigits\n *     minimumSignificantDigits\n *     maximumSignificantDigits\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `NUMBER()`.\n * @param opts The named argments passed to this `NUMBER()`.\n */\nexport function NUMBER(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`NUMBER(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentNumber || arg instanceof FluentDateTime) {\n        return new FluentNumber(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, NUMBER_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to NUMBER\");\n}\nconst DATETIME_ALLOWED = [\n    \"dateStyle\",\n    \"timeStyle\",\n    \"fractionalSecondDigits\",\n    \"dayPeriod\",\n    \"hour12\",\n    \"weekday\",\n    \"era\",\n    \"year\",\n    \"month\",\n    \"day\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"timeZoneName\",\n];\n/**\n * The implementation of the `DATETIME()` builtin available to translations.\n *\n * Translations may call the `DATETIME()` builtin in order to specify\n * formatting options of a number. For example:\n *\n *     now = It's {DATETIME($today, month: \"long\")}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     dateStyle\n *     timeStyle\n *     fractionalSecondDigits\n *     dayPeriod\n *     hour12\n *     weekday\n *     era\n *     year\n *     month\n *     day\n *     hour\n *     minute\n *     second\n *     timeZoneName\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `DATETIME()`.\n * @param opts The named argments passed to this `DATETIME()`.\n */\nexport function DATETIME(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`DATETIME(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentNumber || arg instanceof FluentDateTime) {\n        return new FluentDateTime(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, DATETIME_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to DATETIME\");\n}\n","import { resolveComplexPattern } from \"./resolver.js\";\nimport { Scope } from \"./scope.js\";\nimport { FluentNone } from \"./types.js\";\nimport { NUMBER, DATETIME } from \"./builtins.js\";\n/**\n * Message bundles are single-language stores of translation resources. They are\n * responsible for formatting message values and attributes to strings.\n */\nexport class FluentBundle {\n    /**\n     * Create an instance of `FluentBundle`.\n     *\n     * The `locales` argument is used to instantiate `Intl` formatters used by\n     * translations. The `options` object can be used to configure the bundle.\n     *\n     * Examples:\n     *\n     *     let bundle = new FluentBundle([\"en-US\", \"en\"]);\n     *\n     *     let bundle = new FluentBundle(locales, {useIsolating: false});\n     *\n     *     let bundle = new FluentBundle(locales, {\n     *       useIsolating: true,\n     *       functions: {\n     *         NODE_ENV: () => process.env.NODE_ENV\n     *       }\n     *     });\n     *\n     * Available options:\n     *\n     *   - `functions` - an object of additional functions available to\n     *     translations as builtins.\n     *\n     *   - `useIsolating` - boolean specifying whether to use Unicode isolation\n     *     marks (FSI, PDI) for bidi interpolations. Default: `true`.\n     *\n     *   - `transform` - a function used to transform string parts of patterns.\n     */\n    constructor(locales, { functions, useIsolating = true, transform = (v) => v } = {}) {\n        this._terms = new Map();\n        this._messages = new Map();\n        this._intls = new WeakMap();\n        this.locales = Array.isArray(locales) ? locales : [locales];\n        this._functions = {\n            NUMBER,\n            DATETIME,\n            ...functions\n        };\n        this._useIsolating = useIsolating;\n        this._transform = transform;\n    }\n    /**\n     * Check if a message is present in the bundle.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    hasMessage(id) {\n        return this._messages.has(id);\n    }\n    /**\n     * Return a raw unformatted message object from the bundle.\n     *\n     * Raw messages are `{value, attributes}` shapes containing translation units\n     * called `Patterns`. `Patterns` are implementation-specific; they should be\n     * treated as black boxes and formatted with `FluentBundle.formatPattern`.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    getMessage(id) {\n        return this._messages.get(id);\n    }\n    /**\n     * Add a translation resource to the bundle.\n     *\n     * The translation resource must be an instance of `FluentResource`.\n     *\n     *     let res = new FluentResource(\"foo = Foo\");\n     *     bundle.addResource(res);\n     *     bundle.getMessage(\"foo\");\n     *     //  {value: .., attributes: {..}}\n     *\n     * Available options:\n     *\n     *   - `allowOverrides` - boolean specifying whether it's allowed to override\n     *     an existing message or term with a new value. Default: `false`.\n     *\n     * @param   res - FluentResource object.\n     * @param   options\n     */\n    addResource(res, { allowOverrides = false } = {}) {\n        const errors = [];\n        for (let i = 0; i < res.body.length; i++) {\n            let entry = res.body[i];\n            if (entry.id.startsWith(\"-\")) {\n                // Identifiers starting with a dash (-) define terms. Terms are private\n                // and cannot be retrieved from FluentBundle.\n                if (allowOverrides === false && this._terms.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing term: \"${entry.id}\"`));\n                    continue;\n                }\n                this._terms.set(entry.id, entry);\n            }\n            else {\n                if (allowOverrides === false && this._messages.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing message: \"${entry.id}\"`));\n                    continue;\n                }\n                this._messages.set(entry.id, entry);\n            }\n        }\n        return errors;\n    }\n    /**\n     * Format a `Pattern` to a string.\n     *\n     * Format a raw `Pattern` into a string. `args` will be used to resolve\n     * references to variables passed as arguments to the translation.\n     *\n     * In case of errors `formatPattern` will try to salvage as much of the\n     * translation as possible and will still return a string. For performance\n     * reasons, the encountered errors are not returned but instead are appended\n     * to the `errors` array passed as the third argument.\n     *\n     *     let errors = [];\n     *     bundle.addResource(\n     *         new FluentResource(\"hello = Hello, {$name}!\"));\n     *\n     *     let hello = bundle.getMessage(\"hello\");\n     *     if (hello.value) {\n     *         bundle.formatPattern(hello.value, {name: \"Jane\"}, errors);\n     *         // Returns \"Hello, Jane!\" and `errors` is empty.\n     *\n     *         bundle.formatPattern(hello.value, undefined, errors);\n     *         // Returns \"Hello, {$name}!\" and `errors` is now:\n     *         // [<ReferenceError: Unknown variable: name>]\n     *     }\n     *\n     * If `errors` is omitted, the first encountered error will be thrown.\n     */\n    formatPattern(pattern, args = null, errors = null) {\n        // Resolve a simple pattern without creating a scope. No error handling is\n        // required; by definition simple patterns don't have placeables.\n        if (typeof pattern === \"string\") {\n            return this._transform(pattern);\n        }\n        // Resolve a complex pattern.\n        let scope = new Scope(this, errors, args);\n        try {\n            let value = resolveComplexPattern(scope, pattern);\n            return value.toString(scope);\n        }\n        catch (err) {\n            if (scope.errors) {\n                scope.errors.push(err);\n                return new FluentNone().toString(scope);\n            }\n            throw err;\n        }\n    }\n}\n","// This regex is used to iterate through the beginnings of messages and terms.\n// With the /m flag, the ^ matches at the beginning of every line.\nconst RE_MESSAGE_START = /^(-?[a-zA-Z][\\w-]*) *= */gm;\n// Both Attributes and Variants are parsed in while loops. These regexes are\n// used to break out of them.\nconst RE_ATTRIBUTE_START = /\\.([a-zA-Z][\\w-]*) *= */y;\nconst RE_VARIANT_START = /\\*?\\[/y;\nconst RE_NUMBER_LITERAL = /(-?[0-9]+(?:\\.([0-9]+))?)/y;\nconst RE_IDENTIFIER = /([a-zA-Z][\\w-]*)/y;\nconst RE_REFERENCE = /([$-])?([a-zA-Z][\\w-]*)(?:\\.([a-zA-Z][\\w-]*))?/y;\nconst RE_FUNCTION_NAME = /^[A-Z][A-Z0-9_-]*$/;\n// A \"run\" is a sequence of text or string literal characters which don't\n// require any special handling. For TextElements such special characters are: {\n// (starts a placeable), and line breaks which require additional logic to check\n// if the next line is indented. For StringLiterals they are: \\ (starts an\n// escape sequence), \" (ends the literal), and line breaks which are not allowed\n// in StringLiterals. Note that string runs may be empty; text runs may not.\nconst RE_TEXT_RUN = /([^{}\\n\\r]+)/y;\nconst RE_STRING_RUN = /([^\\\\\"\\n\\r]*)/y;\n// Escape sequences.\nconst RE_STRING_ESCAPE = /\\\\([\\\\\"])/y;\nconst RE_UNICODE_ESCAPE = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{6})/y;\n// Used for trimming TextElements and indents.\nconst RE_LEADING_NEWLINES = /^\\n+/;\nconst RE_TRAILING_SPACES = / +$/;\n// Used in makeIndent to strip spaces from blank lines and normalize CRLF to LF.\nconst RE_BLANK_LINES = / *\\r?\\n/g;\n// Used in makeIndent to measure the indentation.\nconst RE_INDENT = /( *)$/;\n// Common tokens.\nconst TOKEN_BRACE_OPEN = /{\\s*/y;\nconst TOKEN_BRACE_CLOSE = /\\s*}/y;\nconst TOKEN_BRACKET_OPEN = /\\[\\s*/y;\nconst TOKEN_BRACKET_CLOSE = /\\s*] */y;\nconst TOKEN_PAREN_OPEN = /\\s*\\(\\s*/y;\nconst TOKEN_ARROW = /\\s*->\\s*/y;\nconst TOKEN_COLON = /\\s*:\\s*/y;\n// Note the optional comma. As a deviation from the Fluent EBNF, the parser\n// doesn't enforce commas between call arguments.\nconst TOKEN_COMMA = /\\s*,?\\s*/y;\nconst TOKEN_BLANK = /\\s+/y;\n/**\n * Fluent Resource is a structure storing parsed localization entries.\n */\nexport class FluentResource {\n    constructor(source) {\n        this.body = [];\n        RE_MESSAGE_START.lastIndex = 0;\n        let cursor = 0;\n        // Iterate over the beginnings of messages and terms to efficiently skip\n        // comments and recover from errors.\n        while (true) {\n            let next = RE_MESSAGE_START.exec(source);\n            if (next === null) {\n                break;\n            }\n            cursor = RE_MESSAGE_START.lastIndex;\n            try {\n                this.body.push(parseMessage(next[1]));\n            }\n            catch (err) {\n                if (err instanceof SyntaxError) {\n                    // Don't report any Fluent syntax errors. Skip directly to the\n                    // beginning of the next message or term.\n                    continue;\n                }\n                throw err;\n            }\n        }\n        // The parser implementation is inlined below for performance reasons,\n        // as well as for convenience of accessing `source` and `cursor`.\n        // The parser focuses on minimizing the number of false negatives at the\n        // expense of increasing the risk of false positives. In other words, it\n        // aims at parsing valid Fluent messages with a success rate of 100%, but it\n        // may also parse a few invalid messages which the reference parser would\n        // reject. The parser doesn't perform any validation and may produce entries\n        // which wouldn't make sense in the real world. For best results users are\n        // advised to validate translations with the fluent-syntax parser\n        // pre-runtime.\n        // The parser makes an extensive use of sticky regexes which can be anchored\n        // to any offset of the source string without slicing it. Errors are thrown\n        // to bail out of parsing of ill-formed messages.\n        function test(re) {\n            re.lastIndex = cursor;\n            return re.test(source);\n        }\n        // Advance the cursor by the char if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeChar(char, errorClass) {\n            if (source[cursor] === char) {\n                cursor++;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${char}`);\n            }\n            return false;\n        }\n        // Advance the cursor by the token if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeToken(re, errorClass) {\n            if (test(re)) {\n                cursor = re.lastIndex;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${re.toString()}`);\n            }\n            return false;\n        }\n        // Execute a regex, advance the cursor, and return all capture groups.\n        function match(re) {\n            re.lastIndex = cursor;\n            let result = re.exec(source);\n            if (result === null) {\n                throw new SyntaxError(`Expected ${re.toString()}`);\n            }\n            cursor = re.lastIndex;\n            return result;\n        }\n        // Execute a regex, advance the cursor, and return the capture group.\n        function match1(re) {\n            return match(re)[1];\n        }\n        function parseMessage(id) {\n            let value = parsePattern();\n            let attributes = parseAttributes();\n            if (value === null && Object.keys(attributes).length === 0) {\n                throw new SyntaxError(\"Expected message value or attributes\");\n            }\n            return { id, value, attributes };\n        }\n        function parseAttributes() {\n            let attrs = Object.create(null);\n            while (test(RE_ATTRIBUTE_START)) {\n                let name = match1(RE_ATTRIBUTE_START);\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected attribute value\");\n                }\n                attrs[name] = value;\n            }\n            return attrs;\n        }\n        function parsePattern() {\n            let first;\n            // First try to parse any simple text on the same line as the id.\n            if (test(RE_TEXT_RUN)) {\n                first = match1(RE_TEXT_RUN);\n            }\n            // If there's a placeable on the first line, parse a complex pattern.\n            if (source[cursor] === \"{\" || source[cursor] === \"}\") {\n                // Re-use the text parsed above, if possible.\n                return parsePatternElements(first ? [first] : [], Infinity);\n            }\n            // RE_TEXT_VALUE stops at newlines. Only continue parsing the pattern if\n            // what comes after the newline is indented.\n            let indent = parseIndent();\n            if (indent) {\n                if (first) {\n                    // If there's text on the first line, the blank block is part of the\n                    // translation content in its entirety.\n                    return parsePatternElements([first, indent], indent.length);\n                }\n                // Otherwise, we're dealing with a block pattern, i.e. a pattern which\n                // starts on a new line. Discrad the leading newlines but keep the\n                // inline indent; it will be used by the dedentation logic.\n                indent.value = trim(indent.value, RE_LEADING_NEWLINES);\n                return parsePatternElements([indent], indent.length);\n            }\n            if (first) {\n                // It was just a simple inline text after all.\n                return trim(first, RE_TRAILING_SPACES);\n            }\n            return null;\n        }\n        // Parse a complex pattern as an array of elements.\n        function parsePatternElements(elements = [], commonIndent) {\n            while (true) {\n                if (test(RE_TEXT_RUN)) {\n                    elements.push(match1(RE_TEXT_RUN));\n                    continue;\n                }\n                if (source[cursor] === \"{\") {\n                    elements.push(parsePlaceable());\n                    continue;\n                }\n                if (source[cursor] === \"}\") {\n                    throw new SyntaxError(\"Unbalanced closing brace\");\n                }\n                let indent = parseIndent();\n                if (indent) {\n                    elements.push(indent);\n                    commonIndent = Math.min(commonIndent, indent.length);\n                    continue;\n                }\n                break;\n            }\n            let lastIndex = elements.length - 1;\n            let lastElement = elements[lastIndex];\n            // Trim the trailing spaces in the last element if it's a TextElement.\n            if (typeof lastElement === \"string\") {\n                elements[lastIndex] = trim(lastElement, RE_TRAILING_SPACES);\n            }\n            let baked = [];\n            for (let element of elements) {\n                if (element instanceof Indent) {\n                    // Dedent indented lines by the maximum common indent.\n                    element = element.value.slice(0, element.value.length - commonIndent);\n                }\n                if (element) {\n                    baked.push(element);\n                }\n            }\n            return baked;\n        }\n        function parsePlaceable() {\n            consumeToken(TOKEN_BRACE_OPEN, SyntaxError);\n            let selector = parseInlineExpression();\n            if (consumeToken(TOKEN_BRACE_CLOSE)) {\n                return selector;\n            }\n            if (consumeToken(TOKEN_ARROW)) {\n                let variants = parseVariants();\n                consumeToken(TOKEN_BRACE_CLOSE, SyntaxError);\n                return {\n                    type: \"select\",\n                    selector,\n                    ...variants\n                };\n            }\n            throw new SyntaxError(\"Unclosed placeable\");\n        }\n        function parseInlineExpression() {\n            if (source[cursor] === \"{\") {\n                // It's a nested placeable.\n                return parsePlaceable();\n            }\n            if (test(RE_REFERENCE)) {\n                let [, sigil, name, attr = null] = match(RE_REFERENCE);\n                if (sigil === \"$\") {\n                    return { type: \"var\", name };\n                }\n                if (consumeToken(TOKEN_PAREN_OPEN)) {\n                    let args = parseArguments();\n                    if (sigil === \"-\") {\n                        // A parameterized term: -term(...).\n                        return { type: \"term\", name, attr, args };\n                    }\n                    if (RE_FUNCTION_NAME.test(name)) {\n                        return { type: \"func\", name, args };\n                    }\n                    throw new SyntaxError(\"Function names must be all upper-case\");\n                }\n                if (sigil === \"-\") {\n                    // A non-parameterized term: -term.\n                    return {\n                        type: \"term\",\n                        name,\n                        attr,\n                        args: []\n                    };\n                }\n                return { type: \"mesg\", name, attr };\n            }\n            return parseLiteral();\n        }\n        function parseArguments() {\n            let args = [];\n            while (true) {\n                switch (source[cursor]) {\n                    case \")\": // End of the argument list.\n                        cursor++;\n                        return args;\n                    case undefined: // EOF\n                        throw new SyntaxError(\"Unclosed argument list\");\n                }\n                args.push(parseArgument());\n                // Commas between arguments are treated as whitespace.\n                consumeToken(TOKEN_COMMA);\n            }\n        }\n        function parseArgument() {\n            let expr = parseInlineExpression();\n            if (expr.type !== \"mesg\") {\n                return expr;\n            }\n            if (consumeToken(TOKEN_COLON)) {\n                // The reference is the beginning of a named argument.\n                return {\n                    type: \"narg\",\n                    name: expr.name,\n                    value: parseLiteral()\n                };\n            }\n            // It's a regular message reference.\n            return expr;\n        }\n        function parseVariants() {\n            let variants = [];\n            let count = 0;\n            let star;\n            while (test(RE_VARIANT_START)) {\n                if (consumeChar(\"*\")) {\n                    star = count;\n                }\n                let key = parseVariantKey();\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected variant value\");\n                }\n                variants[count++] = { key, value };\n            }\n            if (count === 0) {\n                return null;\n            }\n            if (star === undefined) {\n                throw new SyntaxError(\"Expected default variant\");\n            }\n            return { variants, star };\n        }\n        function parseVariantKey() {\n            consumeToken(TOKEN_BRACKET_OPEN, SyntaxError);\n            let key;\n            if (test(RE_NUMBER_LITERAL)) {\n                key = parseNumberLiteral();\n            }\n            else {\n                key = {\n                    type: \"str\",\n                    value: match1(RE_IDENTIFIER)\n                };\n            }\n            consumeToken(TOKEN_BRACKET_CLOSE, SyntaxError);\n            return key;\n        }\n        function parseLiteral() {\n            if (test(RE_NUMBER_LITERAL)) {\n                return parseNumberLiteral();\n            }\n            if (source[cursor] === '\"') {\n                return parseStringLiteral();\n            }\n            throw new SyntaxError(\"Invalid expression\");\n        }\n        function parseNumberLiteral() {\n            let [, value, fraction = \"\"] = match(RE_NUMBER_LITERAL);\n            let precision = fraction.length;\n            return {\n                type: \"num\",\n                value: parseFloat(value),\n                precision\n            };\n        }\n        function parseStringLiteral() {\n            consumeChar('\"', SyntaxError);\n            let value = \"\";\n            while (true) {\n                value += match1(RE_STRING_RUN);\n                if (source[cursor] === \"\\\\\") {\n                    value += parseEscapeSequence();\n                    continue;\n                }\n                if (consumeChar('\"')) {\n                    return { type: \"str\", value };\n                }\n                // We've reached an EOL of EOF.\n                throw new SyntaxError(\"Unclosed string literal\");\n            }\n        }\n        // Unescape known escape sequences.\n        function parseEscapeSequence() {\n            if (test(RE_STRING_ESCAPE)) {\n                return match1(RE_STRING_ESCAPE);\n            }\n            if (test(RE_UNICODE_ESCAPE)) {\n                let [, codepoint4, codepoint6] = match(RE_UNICODE_ESCAPE);\n                let codepoint = parseInt(codepoint4 || codepoint6, 16);\n                return codepoint <= 0xd7ff || 0xe000 <= codepoint\n                    // It's a Unicode scalar value.\n                    ? String.fromCodePoint(codepoint)\n                    // Lonely surrogates can cause trouble when the parsing result is\n                    // saved using UTF-8. Use U+FFFD REPLACEMENT CHARACTER instead.\n                    : \"\";\n            }\n            throw new SyntaxError(\"Unknown escape sequence\");\n        }\n        // Parse blank space. Return it if it looks like indent before a pattern\n        // line. Skip it othwerwise.\n        function parseIndent() {\n            let start = cursor;\n            consumeToken(TOKEN_BLANK);\n            // Check the first non-blank character after the indent.\n            switch (source[cursor]) {\n                case \".\":\n                case \"[\":\n                case \"*\":\n                case \"}\":\n                case undefined: // EOF\n                    // A special character. End the Pattern.\n                    return false;\n                case \"{\":\n                    // Placeables don't require indentation (in EBNF: block-placeable).\n                    // Continue the Pattern.\n                    return makeIndent(source.slice(start, cursor));\n            }\n            // If the first character on the line is not one of the special characters\n            // listed above, it's a regular text character. Check if there's at least\n            // one space of indent before it.\n            if (source[cursor - 1] === \" \") {\n                // It's an indented text character (in EBNF: indented-char). Continue\n                // the Pattern.\n                return makeIndent(source.slice(start, cursor));\n            }\n            // A not-indented text character is likely the identifier of the next\n            // message. End the Pattern.\n            return false;\n        }\n        // Trim blanks in text according to the given regex.\n        function trim(text, re) {\n            return text.replace(re, \"\");\n        }\n        // Normalize a blank block and extract the indent details.\n        function makeIndent(blank) {\n            let value = blank.replace(RE_BLANK_LINES, \"\\n\");\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            let length = RE_INDENT.exec(blank)[1].length;\n            return new Indent(value, length);\n        }\n    }\n}\nclass Indent {\n    constructor(value, length) {\n        this.value = value;\n        this.length = length;\n    }\n}\n","/**\n * @module fluent\n * @overview\n *\n * `fluent` is a JavaScript implementation of Project Fluent, a localization\n * framework designed to unleash the expressive power of the natural language.\n *\n */\nexport { FluentBundle } from \"./bundle.js\";\nexport { FluentResource } from \"./resource.js\";\nexport { FluentType, FluentNumber, FluentDateTime } from \"./types.js\";\n","import { FluentResource } from \"@fluent/bundle\";\n\nconst enUS = new FluentResource(`\nhello = Hello, { $userName }!\nhello-no-name = Hello, stranger!\ntype-name =\n    .placeholder = Your name\n\n# $date (Date) - Current date, formatted as month and day.\ntoday-date = Today is { DATETIME($date) }.\n# $date (Date) - Current date, formatted as weekday.\ntoday-weekday = Its {$date}.\n\nsign-in-or-cancel = <b>Sign in</b> or <em>cancel</em>.\nclicked-sign-in = You are now signed in.\nclicked-cancel = OK, nevermind.\n\nfavorite-fruit = Favorite Fruit\nfruit-apple = Apple\nfruit-orange = Orange\nfruit-lemon = Lemon\n`);\n\nconst pl = new FluentResource(`\nhello = Cze { $userName }!\n# hello-no-name = Witaj nieznajomy!\ntype-name =\n    .placeholder = Twoje imi\n\n# $date (Date) - Current date, formatted as month and day.\ntoday-date = Dzi jest {DATETIME($date)}.\n\n# Commented out to demonstrate fallback.\n# $date (Date) - Current date, formatted as weekday.\n# today-weekday = Jest {$date}.\n\nsign-in-or-cancel = <b>Zaloguj</b> albo <em>anuluj</em>.\nclicked-sign-in = Brawo!\nclicked-cancel = OK, niewane.\n\nfavorite-fruit = Ulubiony owoc\nfruit-apple = Jabko\nfruit-orange = Pomaraczowy\nfruit-lemon = Cytrynowy\n`);\n\nconst cs = new FluentResource(`\nhello = Ahoj, { $userName }!\nhello-no-name = Vtej cizine!\ntype-name =\n    .placeholder = Tv jmno\n\n# $date (Date) - Current date, formatted as month and day.\ntoday-date = Dnes je { DATETIME($date) }.\n# $date (Date) - Current date, formatted as weekday.\ntoday-weekday = Je {$date}.\n\nsign-in-or-cancel = <b>Pihlsit</b> nebo <em>zruit</em>.\nclicked-sign-in = Nyn jsi pihlen.\nclicked-cancel = Ok, nevad.\n\nfavorite-fruit = Oblben ovoce\nfruit-apple = Jablko\nfruit-orange = Pomeran\nfruit-lemon = Citrn\n`);\n\nconst thTH = new FluentResource(`\nhello =  { $userName }\nhello-no-name = \ntype-name =\n    .placeholder = \n\n# $date (Date) - Current date, formatted as month and day.\ntoday-date =  { DATETIME($date) }\n# $date (Date) - Current date, formatted as weekday.\ntoday-weekday =  {$date}\n\nsign-in-or-cancel = <b></b>  <em></em>\nclicked-sign-in = \nclicked-cancel = \n\nfavorite-fruit = \nfruit-apple = \nfruit-orange = \nfruit-lemon = \n`);\n\nconst eo = new FluentResource(`\nhello = Saluton, { $userName }!\nhello-no-name = Saluton, fremdulo!\ntype-name =\n    .placeholder = Via nomo\n\n# $date (Date) - Current date, formatted as month and day.\ntoday-date = Hodia estas { DATETIME($date) }.\n# $date (Date) - Current date, formatted as weekday.\ntoday-weekday = Estas {$date}.\n\nsign-in-or-cancel = <b>Ensaluti</b> a <em>nuligi</em>.\nclicked-sign-in = Vi estas nun ensalutina.\nclicked-cancel = Bone, ne gravas.\n\nfavorite-fruit = Preferata Frukto\nfruit-apple = Pomo\nfruit-orange = Orano\nfruit-lemon = Citrono\n`);\n\nexport default {\n  \"en-US\": enUS,\n  \"pl\": pl,\n  \"cs\": cs,\n  \"th-TH\": thTH,\n  \"eo\": eo,\n};\n","import { negotiateLanguages } from '@fluent/langneg';\nimport { FluentBundle, FluentResource } from '@fluent/bundle';\nimport { Elm } from \"./Example.elm\";\nimport resources from \"../common/resources.js\";\n\nconst supportedLocales = Object.keys(resources);\n\nfunction getCurrentLocales(desiredLocales) {\n\treturn negotiateLanguages(\n        desiredLocales,\n        supportedLocales,\n        { defaultLocale: 'en-US' }\n    )\n}\n\nfunction getBundles(desiredLocales) {\n    const currentLocales = getCurrentLocales(desiredLocales);\n    const bundles = [];\n\n    for (const locale of currentLocales) {\n        const bundle = new FluentBundle(locale);\n        bundle.addResource(resources[locale]);\n        bundles.push(bundle)\n    }\n\n    return bundles;\n}\n\n// Log translation errors\nwindow.addEventListener(\"fluent-web-error\", function(event) {\n  console.error(event);\n})\n\nconst app = Elm.Example.init({\n  node: document.getElementById(\"root\"),\n  flags: {\n  \tbundles: getBundles(navigator.languages,),\n  \tinitialLocale: getCurrentLocales(navigator.languages)[0],\n  }\n});\n\n\napp.ports.changeDesirecLocale.subscribe(function(locales) {\n\tapp.ports.gotBundles.send(getBundles(locales))\n})\n"]}